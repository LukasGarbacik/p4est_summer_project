/*
  This file is part of p4est.
  p4est is a C library to manage a collection (a forest) of multiple
  connected adaptive quadtrees or octrees in parallel.

  Copyright (C) 2010 The University of Texas System
  Written by Carsten Burstedde, Lucas C. Wilcox, and Tobin Isaac

  p4est is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  p4est is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with p4est; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

/** \page example_userdata A demonstration of how to manage application data
 *
 * This is an example of a typical application workflow with associated data.
 *
 * By design \ref p4est is agnostic of any application data.  It supports
 * two major ways of the application developer managing their simulation
 * data:
 * Stashing it into \ref p4est's quadrant data storage or leaving it
 * external to \ref p4est, allocated and maintained by the application
 * developer.
 *
 * We review both ways below and close with general recommendations.
 * For simplicity, we reference 2D function calls in this document, all of
 * which have analogous versions in 3D.
 *
 * ## p4est-internal element data
 *
 * In \ref p4est, an element is the leaf node of a quadtree (2D) or octree
 * (3D).
 * In the code, we call all nodes of a tree a quadrant, including leaves.
 * The library maintains internal data for each element, to which a fixed
 * amount of user data may be added.
 * If \ref p4est_new_ext or \ref p4est_reset_data is called with a nonzero
 * data size, \ref p4est allocates and maintains this amount of storage in
 * each quadrant.
 * It is accessible to the application developer by the \c p.user_data
 * pointer in each \ref p4est_quadrant.
 *
 * The user data may be initialized by the \ref p4est_init_t callback to the
 * forest \b new, \b refine, \b coarsen, and \b balance functions, for
 * example \ref p4est_refine_ext (see \ref p4est.h and \ref
 * p4est_extended.h).
 *
 * The data may be updated by any other callback to these functions, for
 * example \ref p4est_refine_t or \ref p4est_replace_t.
 * Likewise, the data is accessible from the \ref p4est_iter_volume_t
 * callback as the \c quad member of the \ref p4est_iter_volume_info
 * argument.
 * The volume iterator may be called on a valid forest any time, even
 * without a \ref p4est_ghost layer being present.
 *
 * And finally, the user is very welcome to loop manually over all local
 * trees and their quadrants.
 *
 * On \b repartitioning the mesh for load balancing, the quadrant user data
 * is transferred transparently inside \ref p4est_partition.
 *
 * We also provide the \ref p4est_ghost_exchange_data function to gather the
 * user data of all remote quadrants neighboring to a process.
 *
 * This approach is well suited for typical amounts of refinement metadata
 * (such as indicators and flags) and lightweight numerical data.
 * It is fixed-size: each quadrant has the exact same amount of user data.
 *
 * ## User-allocated element data
 *
 * ## Which way should I choose?
 *
 * The source code for this demonstration resides in \ref
 * userdata/userdata_run2.c (2D) and \ref userdata/userdata_run3.c (3D).
 */

/** \example userdata/userdata2.c
 *
 * A 2D example of managing application data: **main program**.
 *
 * The detailed code for the demonstration resides in \ref
 * userdata/userdata_run2.c.
 *
 * The workflow is documented more extensively in \ref example_userdata.
 */

/** \example userdata/userdata_run2.c
 *
 * A 2D example of managing application data: **core code**.
 *
 * The workflow is documented more extensively in \ref example_userdata.
 *
 * This file contains the code compiled for both the 2D and 3D demo.  This
 * is accomplished with only minimal redefinitions.  We write the code only
 * once and use it twice.  The 3D source \ref userdata/userdata_run3.c is a
 * formal wrapper.  In this sense, the code is mostly dimension independent.
 *
 * This file contains the detailed code of the demo.  Its entry point is
 * called from \ref userdata/userdata2.c, which is a good example of setting
 * up a **main program** and defining and parsing command line options.
 */

/** \example userdata/userdata_run3.c
 *
 * A 3D example of managing application data.
 *
 * The workflow is documented more extensively in \ref example_userdata.
 *
 * The 3D version of th this demo compiles from the same code as the 2D
 * example \ref userdata/userdata_run2.c with minimal redefinitions.  In
 * this sense, the code is mostly dimension independent.
 */
